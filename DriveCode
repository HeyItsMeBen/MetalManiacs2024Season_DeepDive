
package org.firstinspires.ftc.teamcode;
    /* Copyright (c) 2017 FIRST. All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without modification,
     * are permitted (subject to the limitations in the disclaimer below) provided that
     * the following conditions are met:
     *
     * Redistributions of source code must retain the above copyright notice, this list
     * of conditions and the following disclaimer.
     *
     * Redistributions in binary form must reproduce the above copyright notice, this
     * list of conditions and the following disclaimer in the documentation and/or
     * other materials provided with the distribution.
     *
     * Neither the name of FIRST nor the names of its contributors may be used to endorse or
     * promote products derived from this software without specific prior written permission.
     *
     * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS
     * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
     * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.util.ElapsedTime;

    /**
     * This OpMode opens a claw when a is pressed, then closes when b is pressed
     * The code is structured as a LinearOpMode
     * INCREMENT sets how much to increase/decrease the servo position each cycle
     * CYCLE_MS sets the update period.
     *
     * This code assumes a Servo configured with the name "left_hand" as is found on a Robot.
     *
     * NOTE: When any servo position is set, ALL attached servos are activated, so ensure that any other
     * connected servos are able to move freely before running this test.
     *
     * Use Android Studio to Copy this Class, and Paste it into your team's code folder with a new name.
     * Remove or comment out the @Disabled line to add this opmode to the Driver Station OpMode list
     */
    @TeleOp(name = "WorkingMecanumWheelDrive_ReferenceCode", group = "Linear OpMode")
//@Disabled
    public class DriveCode extends LinearOpMode {

        // Driver Code
        private ElapsedTime runtime = new ElapsedTime();
        private DcMotor frontLeftDrive = null;
        private DcMotor backLeftDrive = null;
        private DcMotor frontRightDrive = null;
        private DcMotor backRightDrive = null;
        private float POWER_REDUCTION = 2;

        @Override
        public void runOpMode() {

            // Driver Code
            frontLeftDrive = hardwareMap.get(DcMotor.class, "FrontLeftWheel");
            backLeftDrive = hardwareMap.get(DcMotor.class, "BackLeftWheel");
            frontRightDrive = hardwareMap.get(DcMotor.class, "FrontRightWheel");
            backRightDrive = hardwareMap.get(DcMotor.class, "BackRightWheel");
            // set direction for motors
            frontLeftDrive.setDirection(DcMotor.Direction.REVERSE);
            frontRightDrive.setDirection(DcMotor.Direction.FORWARD);
            backLeftDrive.setDirection(DcMotor.Direction.REVERSE);
            backRightDrive.setDirection(DcMotor.Direction.FORWARD);

            // Wait for the start button
            telemetry.addData(">", "Status: Initialized" );
            telemetry.update();
            waitForStart();
            runtime.reset();
            while (opModeIsActive()) {
                // Drive Code
                double max;
                // POV Mode uses left joystick to go forward & strafe, and right joystick to rotate.
                double axial   = -gamepad1.left_stick_y;  // Note: pushing stick forward gives negative value
                double lateral =  gamepad1.left_stick_x;
                double yaw     =  gamepad1.right_stick_x;
                // Combine the joystick requests for each axis-motion to determine each wheel's power.
                // Set up a variable for each drive wheel to save the power level for telemetry.
                double leftFrontPower  = axial + lateral + yaw;
                double rightFrontPower = axial - lateral - yaw;
                double leftBackPower   = axial - lateral + yaw;
                double rightBackPower  = axial + lateral - yaw;
                // Normalize the values so no wheel power exceeds 100%
                // This ensures that the robot maintains the desired motion.
                max = Math.max(Math.abs(leftFrontPower), Math.abs(rightFrontPower));
                max = Math.max(max, Math.abs(leftBackPower));
                max = Math.max(max, Math.abs(rightBackPower));
                max = POWER_REDUCTION*max; //Reduces power to slow down robot. This can be modified to increase or reduce robot speed by will.
                if (max > 1.0) {
                    leftFrontPower  /= max;
                    rightFrontPower /= max;
                    leftBackPower   /= max;
                    rightBackPower  /= max;
                }
                // Send calculated power to wheels
                frontLeftDrive.setPower(leftFrontPower);
                frontRightDrive.setPower(rightFrontPower);
                backLeftDrive.setPower(leftBackPower);
                backRightDrive.setPower(rightBackPower);

                // Telemetry
                // Claw Code
                // Display the current value

            }

            // Signal done;

            telemetry.addData(">", "Done");
            telemetry.update();
        }
    }

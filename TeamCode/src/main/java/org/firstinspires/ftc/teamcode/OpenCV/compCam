
/*
 * Copyright (c) 2021 OpenFTC Team
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.firstinspires.ftc.teamcode.OpenCV;

//imports
import static java.lang.Thread.sleep;
import com.qualcomm.robotcore.hardware.HardwareMap;
import java.util.ArrayList;

//webcam imports
import org.firstinspires.ftc.robotcore.external.hardware.camera.WebcamName;
import org.openftc.apriltag.AprilTagDetection;
import org.openftc.easyopencv.OpenCvCamera;
import org.openftc.easyopencv.OpenCvCameraFactory;
import org.openftc.easyopencv.OpenCvCameraRotation;

//Main class
public class compCam {
    //double tgtPower = 0;          //delete?

    //setup, including creating objects from imported files
    OpenCvCamera camera;
    AprilTagDetectionPipeline aprilTagDetectionPipeline;
    //creating variables
    static final double FEET_PER_METER = 3.28084;

    // Lens intrinsics
    // UNITS ARE PIXELS
    // NOTE: this calibration is for the C920 webcam at 800x448.
    // You will need to do your own calibration for other configurations!
    double fx = 578.272;
    double fy = 578.272;
    double cx = 402.145;
    double cy = 221.506;

    // UNITS ARE METERS
    double tagsize = 0.166;

    //tag ID's              //THESE LINES ARE IMPORTANT. These are what the camera will be looking for
    int Left = 4;
    int Middle = 5;
    int Right = 6;

    //This variable holds the value (ID) of the april tag that it detects. It's very central to this program
    AprilTagDetection tagOfInterest = null;



    //This is the constructor
    public compCam(HardwareMap hMap) {
        //hardware map the camera
        int cameraMonitorViewId = hMap.appContext.getResources().getIdentifier("cameraMonitorViewId", "id", hMap.appContext.getPackageName());
        camera = OpenCvCameraFactory.getInstance().createWebcam(hMap.get(WebcamName.class, "Webcam 1"), cameraMonitorViewId);
        //create the pipeline object
        aprilTagDetectionPipeline = new AprilTagDetectionPipeline(tagsize, fx, fy, cx, cy);

        //sets the pipeline
        camera.setPipeline(aprilTagDetectionPipeline);
        //Looks like an event listener?
        camera.openCameraDeviceAsync(new OpenCvCamera.AsyncCameraOpenListener()
        {
            @Override
            //starts streaming
            public void onOpened()
            {
                camera.startStreaming(800,448, OpenCvCameraRotation.UPRIGHT);
            }

            @Override
            //probably a fail-safe mechanism
            public void onError(int errorCode)
            {

            }
        });
    }



    //my methods:
    //this method scans for April tags and saves the first one in the 'tagOfInterest' variable
    public void scan() {
        //this gets the ID's of the April Tags that were just detected
        ArrayList<AprilTagDetection> currentDetections = aprilTagDetectionPipeline.getLatestDetections();
        //if the list of detections is NOT empty(meaning if we found at least one tag), run the following code
        if (currentDetections.size() != 0) {
            //resets value for use in the next steps
            boolean tagFound = false;
            //runs the the exact amount of times as there are recent april tags detected. This basically means it runs through every tag to see if we want it (until it breaks)
            for (AprilTagDetection tag : currentDetections) {
                //if the tag is of of the wanted tags, then...
                if (tag.id == Left || tag.id == Middle || tag.id == Right) {
                    //assign the value of that wanted tag to 'tagOfInterest'
                    tagOfInterest = tag;
                    //this means we found a tag that we want
                    tagFound = true;
                    //break from this loop. We don't need anymore tag ID's
                    break;
                }
            }
            //if we did not find a wanted tag AND a tag was found before, then reset 'tagOfInterest' for later use
            if (!tagFound && tagOfInterest != null) {
                tagOfInterest=null;
            }
        }
        //if no tags are currently seen...
        else {
            //if WANTED tags have ever been seen, reset 'tagOfInterest' for later use
            if (tagOfInterest != null) {
                tagOfInterest=null;
            }
        }
    }
    //This method returns the tag ID
    public int tagToId(){
        //if no tags were scanned, return 0
        if (tagOfInterest==null) {
            return 0;
        }
        //otherwise, return the ID of the tag that was found
        else {
            return tagOfInterest.id;
        }
    }
    public double getTelemetry(char mode){
        AprilTagDetection detection=tagOfInterest;
        if (mode=='x'){
            return detection.pose.x*FEET_PER_METER;
        }
        else if (mode=='y'){
            return detection.pose.y*FEET_PER_METER;
        }
        else if (mode=='z'){
            return detection.pose.z*FEET_PER_METER;
        }
        else{
            return 0;
        }
    }

}
